{"ast":null,"code":"// Node.js core modules\nvar crypto = require('crypto');\n/**\n * The encryption algorithm (cipher) type to be used.\n * @type {String}\n * @const\n * @private\n */\n\n\nvar CIPHER_ALGORITHM = 'aes-256-ctr'; //\n// Primary API\n//\n\n/**\n * An API to allow for greatly simplified AES-256 encryption and decryption using a passphrase of\n * any length plus a random Initialization Vector.\n * @exports aes256\n * @public\n */\n\nvar aes256 = {\n  /**\n   * Encrypt a clear-text message using AES-256 plus a random Initialization Vector.\n   * @param {String} key  A passphrase of any length to used to generate a symmetric session key.\n   * @param {String} plaintext  The clear-text message to be encrypted.\n   * @returns {String} A custom-encrypted version of the input.\n   * @public\n   * @method\n   */\n  encrypt: function (key, plaintext) {\n    if (typeof key !== 'string' || !key) {\n      throw new TypeError('Provided \"key\" must be a non-empty string');\n    }\n\n    if (typeof plaintext !== 'string' || !plaintext) {\n      throw new TypeError('Provided \"plaintext\" must be a non-empty string');\n    }\n\n    var sha256 = crypto.createHash('sha256');\n    sha256.update(key); // Initialization Vector\n\n    var iv = crypto.randomBytes(16);\n    var cipher = crypto.createCipheriv(CIPHER_ALGORITHM, sha256.digest(), iv);\n    var ciphertext = cipher.update(new Buffer(plaintext));\n    var encrypted = Buffer.concat([iv, ciphertext, cipher.final()]).toString('base64');\n    return encrypted;\n  },\n\n  /**\n   * Decrypt an encrypted message back to clear-text using AES-256 plus a random Initialization Vector.\n   * @param {String} key  A passphrase of any length to used to generate a symmetric session key.\n   * @param {String} encrypted  The encrypted message to be decrypted.\n   * @returns {String} The original plain-text message.\n   * @public\n   * @method\n   */\n  decrypt: function (key, encrypted) {\n    if (typeof key !== 'string' || !key) {\n      throw new TypeError('Provided \"key\" must be a non-empty string');\n    }\n\n    if (typeof encrypted !== 'string' || !encrypted) {\n      throw new TypeError('Provided \"encrypted\" must be a non-empty string');\n    }\n\n    var sha256 = crypto.createHash('sha256');\n    sha256.update(key);\n    var input = new Buffer(encrypted, 'base64');\n\n    if (input.length < 17) {\n      throw new TypeError('Provided \"encrypted\" must decrypt to a non-empty string');\n    } // Initialization Vector\n\n\n    var iv = input.slice(0, 16);\n    var decipher = crypto.createDecipheriv(CIPHER_ALGORITHM, sha256.digest(), iv);\n    var ciphertext = input.slice(16);\n    var plaintext = decipher.update(ciphertext) + decipher.final();\n    return plaintext;\n  }\n};\n/**\n * Create a symmetric cipher with a given passphrase to then encrypt/decrypt data symmetrically.\n * @param {String} key  A passphrase of any length to used to generate a symmetric session key.\n * @public\n * @constructor\n */\n\nfunction AesCipher(key) {\n  if (typeof key !== 'string' || !key) {\n    throw new TypeError('Provided \"key\" must be a non-empty string');\n  }\n  /**\n   * A passphrase of any length to used to generate a symmetric session key.\n   * @member {String} key\n   * @readonly\n   */\n\n\n  Object.defineProperty(this, 'key', {\n    value: key\n  });\n}\n/**\n * Encrypt a clear-text message using AES-256 plus a random Initialization Vector.\n * @param {String} plaintext  The clear-text message to be encrypted.\n * @returns {String} A custom-encrypted version of the input.\n * @public\n * @method\n */\n\n\nAesCipher.prototype.encrypt = function (plaintext) {\n  return aes256.encrypt(this.key, plaintext);\n};\n/**\n * Decrypt an encrypted message back to clear-text using AES-256 plus a random Initialization Vector.\n * @param {String} encrypted  The encrypted message to be decrypted.\n * @returns {String} The original plain-text message.\n * @public\n * @method\n */\n\n\nAesCipher.prototype.decrypt = function (encrypted) {\n  return aes256.decrypt(this.key, encrypted);\n}; //\n// API Extension\n//\n\n/**\n * Create a symmetric cipher with a given passphrase to then encrypt/decrypt data symmetrically.\n * @param {String} key  A passphrase of any length to used to generate a symmetric session key.\n * @returns {AesCipher}\n * @public\n * @method\n */\n\n\naes256.createCipher = function (key) {\n  return new AesCipher(key);\n}; //\n// Export the API\n//\n\n\nmodule.exports = aes256;","map":{"version":3,"sources":["C:/Users/samde/Documents/Sam/Code/MathRiddles/mathriddles/node_modules/aes256/index.js"],"names":["crypto","require","CIPHER_ALGORITHM","aes256","encrypt","key","plaintext","TypeError","sha256","createHash","update","iv","randomBytes","cipher","createCipheriv","digest","ciphertext","Buffer","encrypted","concat","final","toString","decrypt","input","length","slice","decipher","createDecipheriv","AesCipher","Object","defineProperty","value","prototype","createCipher","module","exports"],"mappings":"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","sourcesContent":["// Node.js core modules\nvar crypto = require('crypto');\n\n\n/**\n * The encryption algorithm (cipher) type to be used.\n * @type {String}\n * @const\n * @private\n */\nvar CIPHER_ALGORITHM = 'aes-256-ctr';\n\n\n//\n// Primary API\n//\n\n/**\n * An API to allow for greatly simplified AES-256 encryption and decryption using a passphrase of\n * any length plus a random Initialization Vector.\n * @exports aes256\n * @public\n */\nvar aes256 = {\n\n  /**\n   * Encrypt a clear-text message using AES-256 plus a random Initialization Vector.\n   * @param {String} key  A passphrase of any length to used to generate a symmetric session key.\n   * @param {String} plaintext  The clear-text message to be encrypted.\n   * @returns {String} A custom-encrypted version of the input.\n   * @public\n   * @method\n   */\n  encrypt: function(key, plaintext) {\n    if (typeof key !== 'string' || !key) {\n      throw new TypeError('Provided \"key\" must be a non-empty string');\n    }\n    if (typeof plaintext !== 'string' || !plaintext) {\n      throw new TypeError('Provided \"plaintext\" must be a non-empty string');\n    }\n\n    var sha256 = crypto.createHash('sha256');\n    sha256.update(key);\n\n    // Initialization Vector\n    var iv = crypto.randomBytes(16);\n    var cipher = crypto.createCipheriv(CIPHER_ALGORITHM, sha256.digest(), iv);\n\n    var ciphertext = cipher.update(new Buffer(plaintext));\n    var encrypted = Buffer.concat([iv, ciphertext, cipher.final()]).toString('base64');\n\n    return encrypted;\n  },\n\n  /**\n   * Decrypt an encrypted message back to clear-text using AES-256 plus a random Initialization Vector.\n   * @param {String} key  A passphrase of any length to used to generate a symmetric session key.\n   * @param {String} encrypted  The encrypted message to be decrypted.\n   * @returns {String} The original plain-text message.\n   * @public\n   * @method\n   */\n  decrypt: function(key, encrypted) {\n    if (typeof key !== 'string' || !key) {\n      throw new TypeError('Provided \"key\" must be a non-empty string');\n    }\n    if (typeof encrypted !== 'string' || !encrypted) {\n      throw new TypeError('Provided \"encrypted\" must be a non-empty string');\n    }\n\n    var sha256 = crypto.createHash('sha256');\n    sha256.update(key);\n\n    var input = new Buffer(encrypted, 'base64');\n\n    if (input.length < 17) {\n      throw new TypeError('Provided \"encrypted\" must decrypt to a non-empty string');\n    }\n\n    // Initialization Vector\n    var iv = input.slice(0, 16);\n    var decipher = crypto.createDecipheriv(CIPHER_ALGORITHM, sha256.digest(), iv);\n\n    var ciphertext = input.slice(16);\n    var plaintext = decipher.update(ciphertext) + decipher.final();\n\n    return plaintext;\n  }\n\n};\n\n\n\n\n/**\n * Create a symmetric cipher with a given passphrase to then encrypt/decrypt data symmetrically.\n * @param {String} key  A passphrase of any length to used to generate a symmetric session key.\n * @public\n * @constructor\n */\nfunction AesCipher(key) {\n  if (typeof key !== 'string' || !key) {\n    throw new TypeError('Provided \"key\" must be a non-empty string');\n  }\n\n  /**\n   * A passphrase of any length to used to generate a symmetric session key.\n   * @member {String} key\n   * @readonly\n   */\n  Object.defineProperty(this, 'key', { value: key });\n\n}\n\n/**\n * Encrypt a clear-text message using AES-256 plus a random Initialization Vector.\n * @param {String} plaintext  The clear-text message to be encrypted.\n * @returns {String} A custom-encrypted version of the input.\n * @public\n * @method\n */\nAesCipher.prototype.encrypt = function(plaintext) {\n  return aes256.encrypt(this.key, plaintext);\n};\n\n/**\n * Decrypt an encrypted message back to clear-text using AES-256 plus a random Initialization Vector.\n * @param {String} encrypted  The encrypted message to be decrypted.\n * @returns {String} The original plain-text message.\n * @public\n * @method\n */\nAesCipher.prototype.decrypt = function(encrypted) {\n  return aes256.decrypt(this.key, encrypted);\n};\n\n\n\n\n//\n// API Extension\n//\n\n\n/**\n * Create a symmetric cipher with a given passphrase to then encrypt/decrypt data symmetrically.\n * @param {String} key  A passphrase of any length to used to generate a symmetric session key.\n * @returns {AesCipher}\n * @public\n * @method\n */\naes256.createCipher = function(key) {\n  return new AesCipher(key);\n};\n\n\n\n\n//\n// Export the API\n//\n\nmodule.exports = aes256;\n"]},"metadata":{},"sourceType":"script"}